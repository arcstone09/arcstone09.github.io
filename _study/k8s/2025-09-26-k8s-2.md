---
title: "[K8S] 2 First steps with Docker and Kubernetes"
date: 2025-09-26
permalink: /study/2025-09-26-k8s-2
categories: K8S
tags:
  - K8S

---

In this post, chapter 2 of Kubernetes in Action is introduced. 



# 2.1 Creating, running, and sharing a container image

MacOS에서 docker를 설치하면 linux VM 안에서 docker daemon이 실행되고, 유저는 host OS에서 docker client를 이용해 docker를 이용할 수 있다. Docker를 설치한 후 다음 커맨드를 입력했을 때 벌어지는 일을 살펴보자.

```zsh 
docker run busybox echo "Hello world"  
```

docekr는 우선 busybox image가 로컬 머신에 있는지 확인한다. 없으므로, Docker Hub Registry에서 image를 pull 한다. 도커는 image로부터 컨테이너를 만들고 echo 명령어를 실행한다. 





📖 **Port**

네트워크에서 한 컴퓨터(=IP 주소) 안에 여러 프로그램이 동시에 통신할 수 있도록 구분하는 논리적 번호이다. (Ex. 80 → HTTP 서버, 22 → SSH) 즉, 포트는 **소켓(socket)** 이라는 "프로세스별 네트워크 통신 창구"에 붙는 번호이다. OS 커널은 TCP/UDP 스택을 관리한다. 프로세스가 `bind(8080)` 하면 커널은 "이 프로세스는 이제 8080번 포트로 들어오는 TCP 연결을 처리 (커널 내부 자료구조)"라고 기록한다. 클라이언트가 이 컴퓨터의 8080포트로 패킷을 보내면 커널이 해당 프로세스로 그 패킷(01 비트들의 집합)을 전달한다. 즉, 단계별로 정리하면 아래와 같다. 

1. **소켓 생성**

- 유저 프로세스가 `socket()` 시스템 콜 호출
- 커널이 `struct socket` 자료구조를 메모리에 생성하고, 파일 디스크립터(fd)를 반환

2. **주소 바인딩**

- `bind(fd, IP:port)` → 커널이 "이 소켓은 192.168.0.10:8080 담당”이라고 기록

3. **연결 & 통신**

- `listen()`, `accept()` → 서버 소켓 준비
- `connect()` → 클라이언트 연결
- 이후 `send()`, `recv()` → 커널 TCP/IP 스택이 소켓을 통해 패킷 송수신

4. **해제**

- `close(fd)` → 커널이 `struct socket` 자료구조를 제거

Docker 컨테이너는 **리눅스 네임스페이스**로 네트워크가 격리되어 있다. 그래서 컨테이너 안에서 `app.listen(8080)` 하면, 그건 컨테이너 네트워크 공간의 8080 포트를 의미한다. 예를 들어 컨테이너에서 다음 프로세스가 실행된다고 해보자.

```js
const http = require('http');
http.createServer((req, res) => {
  res.end("Hello");
}).listen(8080);
```

Node.js가 내부적으로 `socket() → bind() → listen()` 시스템 콜을 호출한다. 그러면 컨테이너 네트워크 네임스페이스 안에서 포트 8080을 사용하는 소켓이 호스트 커널에 등록된다(커널이 "이 소켓은 이 네임스페이스 안의 0.0.0.0 IP, 8080 포트를 담당한다."고 기록)

호스트에서는 컨테이너의 8080 포트를 바로 볼 수 없기 때문에 **포트 포워딩**(port mapping)을 해주는 게 `-p 8080:8080` 옵션이다.

