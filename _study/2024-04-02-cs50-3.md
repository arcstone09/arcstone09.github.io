---
title: "[CS50] 03 Compiler & Array"
date: 2024-04-02
permalink: /study/2024-04-02-cs50-3
categories: basic
tags:
  - array
---

In this post, the third lecture of CS50 is summarized.

# Compiler
In order to compile 'hello.c' file and execute it, we write as follow.
```console
$ make hello
$ ./hello
```
However, 'make' is actually running another command for us. 'make' itself is not a compiler but a program that automatically runs a compiler. The compiler we have been using is Clang. By defualt, Clang outputs a file name 'a.out' But by using a command-line arguments(additional words or shorthand notation user typed at command prompt that modify the behavior of a program.) you can determine the name of a program. 
```console
$ clang -o hello hello.c
$ ./hello
```
Let's try to compile the source code below.
```c
#include <cs50.h>
#include <stdio.h>

int main(void){
  string name = get_string("What's your name? ");
  printf("hello, %s\n", name);
}
```
In this case, since we are using a third-party library that does not necessarily come with C, we have to tell the compiler that we want to use that library. Not just by including the header file, but by an additional command as well.
```console
$ clang -o hello hello.c -lcs50
$ ./hello
```
'make' is a popular tool in the real world that automates these processes.
The process of translating source code into machine code consists of four main stages - preprocessing, compiling, assembling, and linking. Let's explore each stage.
## preprocessing
In the code below, there are two lines that starts with #. Any line of C that starts with this hash symbol is called preprocessor directive. 
```c
#include <cs50.h>
#include <stdio.h>

int main(void){
  string name = get_string("What's your name? ");
  printf("hello, %s\n", name);
}
```
'cs50.h' is a file tha CS50 staff wrote and installed somewhere in online VS Code, somewhere in the cloud. In 'cs50.h', the prototype of 'get_string' function is written. When you compile your code, the first step is changing the pre-processing line. Essentially, there is some code inside of the clang compiler that looks for a line that starts with '#include', and finds the corresponding file and copies/pastes the contents of the file right there into your code. 
```c
string get_string(string prompt);
int printf(string format, ...);

int main(void){
  string name = get_string("What's your name? ");
  printf("hello, %s\n", name);
}
```
In short, preprocessing converts all of those '#include' lines to the underlying prototypes.
## compiling 
In this process, the compiler converts C to assembly language as below.
            picture of the assembly
Before there was C, humans wrote assembly language to program. Before there was assembly code, humans directly wrotes the machine code, be it in code or be it in punch cards.
## assembling
In assembling, the compiler takes the assembly code and converts it to 0's and 1's. The reason that Clang names its files 'a.out' is a side effect of that being one of the steps in this process, dealing with assembly language and its subsequent output.
## linking
Let's see the code again.
```c
#include <cs50.h>
#include <stdio.h>

int main(void){
  string name = get_string("What's your name? ");
  printf("hello, %s\n", name);
}
```
There are 3 different files involved in compiling - hello.c, cs50.h, and stdio.h. Technically somewhere else on the computer's hard drive is a 'cs50.c' file which actually contains the implementation of 'get_string'. The compiler, needs to compile each file - hello.c, cs50.c, stdio.c - into 0's and 1's. In the process of linking, the compiler takes all of 0's and 1's from each file and combines them into one final file.

# Memory
