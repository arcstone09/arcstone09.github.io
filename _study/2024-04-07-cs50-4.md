---
title: "[CS50] 04 Algorithm"
date: 2024-04-07
permalink: /study/2024-04-07-cs50-4
categories: basic
tags:
  - algorithm
---

In this post, the fourth lecture of CS50 is summarized.

# Search algorithm
## Linear search
Anytime you search from left to right or from right to left, it's called linear search.
## Binary search
Pseudo code for the binary sesarch algorithm.
```
If no doors left
  Return false
If 50 is behind doors[miidle]
  Return true
Else if 50 < doors[middle]
  Search doors[0] thorugh doors[middle - 1]
Else if 50 > doors[middle]
  Search doors[middle + 1] through doors[n - 1]
```
## Running Time
Although there is a more formal mathematical definition for the terms introduced below, for now we'll briefly learn about the symbols used at expressing the running time of the algorithm.
* $O$ refers to the upper bound of the running time. For example, binary search is $O(logn)$.
* $\Omega$ refers to the lower bound of the running time. For example, binary search is $\Omega(1)$.
* If $O$ and $\Omega$ happen to be the same, we can use $\Theta$.



# strcmp
In string.h there is a function strcmp which compares the two string parameters and tells whether they are same. It retuns 0 if they are same. Why might it be valuable for strcmp function to return 0 if the strings are equal as opposed to a simple Boolean like true or false? It turns out strcmp actually compares the two strings for equality but also for what's called, ASCII-betical order. It compares the integer values of the letters. If I use '==' to compare two strings, I was not comparing the strings in the wway that you might have thought. '==' is doing something different in python or java than it is doing in C. More details on next week.



# structs
C allows us to create our own data structures, our own types of variables.
```c
typedef struct
{
  string name;
  string number;
}
person;
```
Using 'struct' we can create our own data structure. A structure can be a variable that contains any number of other variables. 'typedef' is a keyword that means define the following type.
```c
int main(void){
  person people[3];

  people[0].name = "LEE";
  people[0].number = "010-0000-0000";
}
```
In order to initialize 'people', we use dot to access their name and number field.



# Sorting
## Selection sort
I select the element I want again and again on the basis of how small it is. I look for the smallest, then the next smallest, and so forth. 
```
For i from 0 to n-1
  Find smallest number between numbers[i] and numbers[n-1]
  Swap smallest number with numbers[i]
```
If we have n numbers, $(n-1)$ comparisons occurs to find the smallest number. $(n-2)$ for the next one. Thus, $O(n^{2})$. With selection sort, what would be the best case scenario be? The best case would be every element is already sorted. But does selection sort appreciate that? The answer is no since selection sort does not take into account whether the list is already sorted. There's no special conditional 'if it's already sorted exit early'. Thus, it is $\Omega(n^{2})$. Also, $\Theta(n^{2})$.

## Bubble sort
I fix local problems again and again until I fix all of the minor problems.
```
Repeat n times
  For i from 0 to n-2
```
















